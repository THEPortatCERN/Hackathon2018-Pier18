<html>
  <head>
    <meta charset="utf-8">
    <title>Visualization</title>
    <link rel="stylesheet" href="scatter.css" charset="utf-8">
  </head>
  <script type="text/javascript">

  </script>
  <body>
    <div id="scatter"></div>

    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>
    <script>

      // TODO: First list all the documents in the database
      // TODO: Select one of them to get the duplication analysis
      // TODO: Add support for large number of query words in solr
      // TODO: normalization of data (remove self) - need to get self from the database
      // DONE: zoom
      // IN PROGRESS: show human readable date
      const query = "The negative impacts of the El Nino induced drought";

      fetch('http://128.141.118.30:8983/solr/deep/select?fl=title,publisher,published_date,id,score', {
        method: 'POST',
        headers: { "Content-Type": "application/json; charset=utf-8" },
        body: JSON.stringify({ query, limit: 300 }),
      })
        .then(res => res.json())
        .then((json) => {

          const data = json.response.docs
            // remove all data without published_date
            .filter(datum => datum['published_date'] !== 'None' && datum['published_date'])
            // transform data to our needs
            .map(datum => ({
              ...datum,
              size: 3,
              published_date: new Date(datum.published_date).getTime() / 1000,
              publisher: datum.publisher || 'N/A',
            }))

          const margin = { top: 50, right: 300, bottom: 50, left: 50 };
          const outerWidth = 1420;
          const outerHeight = 680;
          const width = outerWidth - margin.left - margin.right;
          const height = outerHeight - margin.top - margin.bottom;

          var x = d3.scale.linear().range([0, width]).nice();
          var y = d3.scale.linear().range([height, 0]).nice();

          const colorCat = "publisher";
          const rCat = 'size';
          const xCat = "published_date";
          const yCat = "score";

          let maxX = Math.max(...data.map(datum => datum[xCat]));
          let minX = Math.min(...data.map(datum => datum[xCat]));
          let maxY = Math.max(...data.map(datum => datum[yCat]));
          let minY = Math.min(...data.map(datum => datum[yCat]));

          let xMax = maxX+1;
          let xMin = minX;
          let yMax = maxY+10;
          let yMin = minY;

          x.domain([xMin, xMax]);
          y.domain([yMin, yMax]);

          const xAxis = d3.svg.axis()
            .scale(x)
            .orient("bottom")
            .tickSize(-height)
            .tickFormat(d3.format("d"));

          const yAxis = d3.svg.axis()
            .scale(y)
            .orient("left")
            .tickSize(-width);

          var color = d3.scale.category20();

          var tip = d3.tip()
            .attr("class", "d3-tip")
            .offset([-10, 0])
            .html(function(d) {
	      return `Title: ${d.title}<br>Date: ${d[xCat]}<br>Similarity: ${d[yCat]}<br>Publisher: ${d[colorCat]}`;
            });

          var zoomBeh = d3.behavior.zoom()
            .x(x)
            .y(y)
            .scaleExtent([0, 500])
            .on("zoom", zoom);

          var svg = d3.select("#scatter")
            .append("svg")
            .attr("width", outerWidth)
            .attr("height", outerHeight)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
            .call(zoomBeh);

          svg.call(tip);

          svg.append("rect")
            .attr("width", width)
            .attr("height", height);

          svg.append("g")
            .classed("x axis", true)
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis)
            .append("text")
            .classed("label", true)
            .attr("x", width)
            .attr("y", margin.bottom - 10)
            .style("text-anchor", "end")
            .text("Time");

          svg.append("g")
            .classed("y axis", true)
            .call(yAxis)
            .append("text")
            .classed("label", true)
            .attr("transform", "rotate(-90)")
            .attr("y", -margin.left)
            .attr("dy", ".71em")
            .style("text-anchor", "end")
            .text("Similarity");

          var objects = svg.append("svg")
            .classed("objects", true)
            .attr("width", width)
            .attr("height", height);

          objects.append("svg:line")
            .classed("axisLine hAxisLine", true)
            .attr("x1", 0)
            .attr("y1", 0)
            .attr("x2", width)
            .attr("y2", 0)
            .attr("transform", "translate(0," + height + ")");

          objects.append("svg:line")
            .classed("axisLine vAxisLine", true)
            .attr("x1", 0)
            .attr("y1", 0)
            .attr("x2", 0)
            .attr("y2", height);

          objects.selectAll(".dot")
            .data(data)
            .enter().append("circle")
            .classed("dot", true)
            .attr("r", function (d) { return 6 * Math.sqrt(d[rCat] / Math.PI); })
            .attr("transform", transform)
            .style("fill", function(d) { return color(d[colorCat]); })
            .on("mouseover", tip.show)
            .on("mouseout", tip.hide);

          var legend = svg.selectAll(".legend")
            .data(color.domain())
            .enter().append("g")
            .classed("legend", true)
            .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

          legend.append("circle")
            .attr("r", 3.5)
            .attr("cx", width + 20)
            .attr("fill", color);

          legend.append("text")
            .attr("x", width + 26)
            .attr("dy", ".35em")
            .text(function(d) { return d; });

          d3.select("input").on("click", change);

          function change() {
            xCat = "Carbs";
            xMax = d3.max(data, function(d) { return d[xCat]; });
            xMin = d3.min(data, function(d) { return d[xCat]; });

            zoomBeh.x(x.domain([xMin, xMax])).y(y.domain([yMin, yMax]));

            var svg = d3.select("#scatter").transition();

            svg.select(".x.axis").duration(750).call(xAxis).select(".label").text(xCat);

            objects.selectAll(".dot").transition().duration(1000).attr("transform", transform);
          }

          function zoom() {
            svg.select(".x.axis").call(xAxis);
            svg.select(".y.axis").call(yAxis);

            svg.selectAll(".dot")
              .attr("transform", transform);
          }

          function transform(d) {
            return "translate(" + x(d[xCat]) + "," + y(d[yCat]) + ")";
          }
        })
        .catch(res => console.warn(res));
    </script>
  </body>
</html>
